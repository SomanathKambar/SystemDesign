# Low Level Design: Fixed Window Strategy

## 1. Algorithm Overview
The **Fixed Window** algorithm divides time into fixed intervals (windows) of size `W`. Each window has a counter initialized to 0. Requests increment the counter for the current window. If the counter exceeds the limit `L`, requests are dropped until the next window starts.

## 2. Class Design

### `FixedWindowRateLimiter`
- **Package**: `com.systemdesign.infra.ratelimiter.strategy.fixedwindow`
- **Dependencies**: 
  - `Clock`: For testable time retrieval.
  - `StateStore`: For persisting counters.

#### Properties
- `limit` (Int): Max requests allowed per window.
- `windowSizeMs` (Long): Duration of the window in milliseconds.

#### Key Methods

`allow(key: String): Decision`
1.  **Time Resolution**: 
    ```kotlin
    now = clock.millis()
    windowStart = (now / windowSizeMs) * windowSizeMs
    ```
2.  **Key Generation**:
    ```kotlin
    windowKey = "$key:$windowStart"
    ```
3.  **State Retrieval**:
    ```kotlin
    currentCount = stateStore.get(windowKey)?.count ?: 0
    ```
4.  **Logic**:
    - If `currentCount >= limit`:
        - Calculate `retryAfter = (windowStart + windowSizeMs) - now`
        - Return `Decision(false, retryAfter)`
    - Else:
        - `newCount = currentCount + 1`
        - `stateStore.save(windowKey, CounterState(newCount), ttl=windowSizeMs)`
        - Return `Decision(true)`

## 3. Data Structures

### `CounterState`
Used to store the value in the `StateStore`.
```kotlin
data class CounterState(
    val count: Long,
    val windowStart: Long
)
```

## 4. Edge Cases & Handling

1.  **Clock Skew**: In a distributed environment, if server clocks are not synced, "current window" might differ. 
    - *Mitigation*: Use a centralized data store (Redis) with TTLs. The logic relies on the timestamp generated by the *application server*. Minor skews result in slightly shifted windows but generally acceptable for rate limiting.
2.  **Race Conditions** (Read-Modify-Write):
    - Two requests read `count=9` (limit 10) simultaneously. Both increment to 10.
    - *Result*: 11 requests pass. 
    - *Acceptance*: For soft rate limiting, this is often acceptable to avoid locking overhead.
    - *Strict Mode*: Would require `INCR` atomic operations in Redis or Locks in memory. *Current implementation is "Soft" (Read-Modify-Write).*

## 5. Complexity Analysis

- **Time Complexity**: `O(1)` - Simple arithmetic and a map lookup/write.
- **Space Complexity**: `O(U)` where `U` is the number of unique active users/keys.
    - Old windows are automatically cleaned up via TTL or lazy eviction strategies in the store.

## 6. Testing Strategy
- **Unit Tests**:
    - Mock `Clock` to simulate time passage.
    - Mock `StateStore` to verify interactions.
    - Verify:
        - Requests under limit -> Allowed.
        - Request over limit -> Denied.
        - Window transition -> Counter resets (New key used).
